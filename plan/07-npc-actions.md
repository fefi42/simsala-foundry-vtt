# Plan 07 — NPC Actions, Reactions, Legendary Actions & Spells

**Goal:** Extend the NPC generation pipeline to equip NPCs with abilities — attacks, passive traits, special actions, reactions, legendary actions, and spells — on top of the stat block generated by waves 1–5.

---

## Context

Waves 1–5 produce **actor update fields** applied via `document.update()`. Abilities are different: they are **embedded Item documents** created via `actor.createEmbeddedDocuments("Item", [...])`.

There are hundreds of spells and dozens of standard monster abilities. Rather than having the LLM generate these from scratch (error-prone, legally problematic), we use a **catalog system** — config files that organize compendium items into thematic groups. An LLM-driven **map-reduce selection pipeline** picks the right abilities from the catalog for a given NPC.

Attacks (Bite, Claw, etc.) remain generated because natural weapons are too creature-specific to catalog.

---

## 1. Embedded Item Infrastructure

**Files:** `scripts/ItemGeneratorApp.js`

### Convention

`mapResult()` can return an `_embedded` key containing item creation data:

```js
{
  system: { ... },                    // actor update (existing)
  _embedded: { Item: [ ... ] },       // embedded item creates (new)
}
```

### Changes to `ItemGeneratorApp.js`

- Add `this.lastEmbeddedItems = []` in constructor
- Add `_extractEmbedded(mapped)` helper — splits `_embedded.Item` from actor update data
- In `_generate()`: after each `mapResult`, extract embedded items into a running list, merge the rest as before
- `await` all `mapResult()` calls (harmless on sync returns, needed for compendium lookups)
- In `_onApply()`:
  - Call `document.update(lastResult)` for actor fields (existing)
  - Delete existing items flagged `flags.simsala.generated = true`
  - Call `document.createEmbeddedDocuments("Item", flaggedItems)` for new items
- Pass embedded item summaries (names/types) in `prior` context for later wave prompts
- Update follow-up context in `_onSend()` to include embedded item names

### Chat display

Show embedded items as a readable list below the actor JSON, not raw item data dumps.

---

## 2. Ability Catalog

A config-driven index of compendium items organized into thematic groups. The catalog is the foundation for the selection pipeline (section 3) and is designed to be extended without code changes — adding support for a new compendium or 3rd-party module is just adding a config file.

### Config format

One JSON file per content source, stored in `data/catalogs/`. Example `data/catalogs/srd-spells.json`:

```json
{
  "source": "dnd5e.spells",
  "groups": [
    {
      "id": "evocation-damage",
      "description": "Offensive spells that deal direct elemental or force damage — fireballs, lightning bolts, magic missiles",
      "items": [
        { "name": "Fireball", "summary": "3rd level, 8d6 fire, 20ft sphere, DEX save" },
        { "name": "Lightning Bolt", "summary": "3rd level, 8d6 lightning, 100ft line, DEX save" },
        { "name": "Magic Missile", "summary": "1st level, 3×1d4+1 force, auto-hit, scales +1 dart/level" }
      ]
    },
    {
      "id": "abjuration-defense",
      "description": "Protective spells — shields, wards, counterspells, banishments",
      "items": [
        { "name": "Shield", "summary": "1st level, reaction, +5 AC until next turn" },
        { "name": "Counterspell", "summary": "3rd level, reaction, negate spell ≤3rd level" }
      ]
    }
  ]
}
```

Key design points:
- **`source`** is the Foundry compendium pack ID. Items are loaded from this pack at runtime by name. No item data is stored in the config — this keeps configs legal to distribute (they contain only names and brief mechanical summaries for the LLM).
- **`summary`** is a short mechanical description for the LLM to make informed choices. It does NOT need to be complete — just enough for selection.
- **`description`** on each group is what the LLM sees in step 1 (map) to decide which groups to explore.
- Multiple catalog files can reference the same compendium pack (e.g. spells split across several files by theme).
- Multiple catalog files can reference different packs (SRD spells, 3rd-party spells, homebrew).

### Catalog types

Separate catalog files for different ability categories:

- `data/catalogs/srd-spells.json` — SRD spells grouped by school/theme
- `data/catalogs/srd-abilities.json` — standard monster abilities (passive traits, actions, reactions, legendary actions) from the SRD monsters compendium

Future additions (out of scope):
- `data/catalogs/xge-spells.json`, `data/catalogs/tce-spells.json`, etc.
- 3rd-party module catalogs

### Catalog loader

**New file:** `scripts/catalog.js`

```js
export class CatalogRegistry {
  static _catalogs = [];

  // Load all catalog JSON files, called once on module init
  static async loadAll() { ... }

  // Return all groups across all catalogs, with their descriptions
  static getGroupIndex() { ... }

  // Return items for specific group IDs, resolved from compendium at runtime
  static async resolveGroups(groupIds) { ... }
}
```

`resolveGroups()` loads actual item documents from the compendium pack (`game.packs.get(source)`) by name lookup. Returns full Foundry item data ready for `createEmbeddedDocuments`. Caches the compendium index to avoid repeated lookups.

---

## 3. Catalog Selection Pipeline (Map-Reduce)

A 3-step LLM-driven selection process. All steps receive NPC context (name, CR, creature type, ability scores, etc.) so decisions are thematically and mechanically appropriate.

### Step 1 — Map: Group Selection

The LLM sees:
- NPC context (name, CR, type, size, abilities from prior waves)
- The GM's original description
- A list of all group descriptions from the catalog (just IDs + descriptions, no individual items)

The LLM returns which groups to explore and an optional refinement prompt per group:

```json
{
  "selectedGroups": [
    { "groupId": "evocation-damage", "refinement": "fire-themed, levels 1-5" },
    { "groupId": "abjuration-defense", "refinement": "" },
    { "groupId": "monster-passive-traits", "refinement": "fire resistance or immunity related" }
  ]
}
```

The refinement prompt lets the LLM narrow the search (e.g. "fire-themed" for a fire elemental) without needing sub-groups for every combination.

### Step 2 — Parallel Explore: Candidate Selection

For each selected group, in parallel:
- Load the group's items (names + summaries from config)
- Send to LLM with NPC context + the refinement prompt
- LLM returns exactly **3 candidates** (or fewer if the group is small)

```json
{
  "candidates": [
    { "name": "Fireball", "reason": "Core damage spell appropriate for CR 7 fire creature" },
    { "name": "Scorching Ray", "reason": "Multi-target option, thematic" },
    { "name": "Fire Bolt", "reason": "At-will cantrip for ranged option" }
  ]
}
```

The `reason` field gives the step-3 LLM context for its final decision.

### Step 3 — Reduce: Final Assembly

The LLM sees all candidates across all groups and makes the final selection:
- NPC context
- All candidates with their reasons
- CR-appropriate limits (e.g. "CR 5: 4–6 abilities total, CR 15: 8–12 abilities total")
- Instructions to build a balanced loadout (mix of offense, defense, utility)

The LLM returns the final selection, assigning a spellcasting mode where applicable:

```json
{
  "spellcastingAbility": "int",
  "spellcastingLevel": 7,
  "selected": [
    { "name": "Fireball", "mode": "prepared" },
    { "name": "Fire Bolt", "mode": "atwill" },
    { "name": "Shield", "mode": "prepared" },
    { "name": "Magic Resistance", "mode": "" }
  ]
}
```

`mode` values: `"prepared"` (slot-based), `"atwill"`, `"innate"` (1-3/day), `""` (non-spell abilities).

### After step 3: Compendium Resolution

Code resolves the selected names against their compendium packs via `CatalogRegistry.resolveGroups()`. Items not found in the compendium are logged as warnings and skipped. The resolved items are returned as `_embedded.Item` data with appropriate flags set (spellcasting mode, preparation status).

---

## 4. Attack Generation (Wave-Based)

Attacks remain **generated** rather than catalog-sourced. Natural weapons (Bite, Claw, Tail) are too creature-specific — their damage, reach, and extra effects vary by creature size, CR, and theme. No standard compendium covers this.

**Group:** `attacks` in `npc-groups.js`

**LLM outputs:**
```json
{
  "hasMultiattack": true,
  "multiattackDescription": "The dragon makes three attacks: one with its bite and two with its claws.",
  "attacks": [{
    "name": "Bite", "attackType": "melee", "reach": 10,
    "damageFormula": "2d10+6", "damageType": "piercing",
    "extraDamageFormula": "1d10", "extraDamageType": "fire",
    "description": ""
  }]
}
```

**mapResult** → embedded items:
- Multiattack as a description-only feat (if `hasMultiattack`)
- Each attack as a weapon item (`system.type.value = "natural"`, dnd5e auto-creates the attack activity)
- Extra damage (e.g. "plus 2d6 fire") included in the weapon description text

**Prompt includes:** CR-appropriate damage benchmarks.

---

## 5. Actor-Level Resources

Set alongside the catalog selection results. These are actor update fields, not embedded items.

- `system.resources.legact.max` — legendary action count (from step 3, based on whether legendary actions were selected)
- `system.resources.legres.max` — legendary resistance count
- `system.attributes.spellcasting` — spellcasting ability (from step 3)
- `system.attributes.spell.level` — spellcaster level (from step 3)

---

## 6. Updated Wave Pipeline

```js
export const NPC_WAVES = [
  ["concept"],                              // Wave 1 — name, CR, creature type
  ["mechanical"],                           // Wave 2 — size, immunities, movement
  ["coreStats"],                            // Wave 3 — abilities, AC, HP
  ["savesSkills", "sensesLanguages"],        // Wave 4 — parallel
  ["description"],                          // Wave 5 — biography
  ["attacks"],                              // Wave 6 — generated natural weapons
  ["catalogSelection"],                     // Wave 7 — map-reduce catalog pipeline (3 LLM steps internally)
];
```

`catalogSelection` is a single group in the wave pipeline but internally runs the 3-step map-reduce. From the pipeline's perspective it's one wave that returns `_embedded.Item` and actor updates (spellcasting, legendary resources).

---

## 7. Implementation Steps

1. **Embedded item infrastructure** — `_extractEmbedded`, updated `_generate`, updated `_onApply`, updated `_onSend` context in `ItemGeneratorApp.js`
2. **Catalog config format** — create `data/catalogs/` directory, write initial `srd-spells.json` and `srd-abilities.json` with thematic groups
3. **Catalog loader** — `scripts/catalog.js` with `CatalogRegistry` class (load configs, group index, compendium resolution)
4. **Map-reduce selection pipeline** — `scripts/catalog-selection.js` implementing the 3-step LLM selection, returns `_embedded` + actor updates
5. **`catalogSelection` group** in `npc-groups.js` — wires the pipeline into the wave system
6. **`attacks` group** in `npc-groups.js` — generated natural weapons with multiattack
7. **Follow-up context** — update `_onSend` to include embedded item names in refinement prompt

---

## 8. Catalog Authoring Guide

For extending the catalog with new content (future compendiums, 3rd-party modules):

1. Create a new JSON file in `data/catalogs/`
2. Set `source` to the Foundry compendium pack ID (e.g. `"my-module.spells"`)
3. Organize items into thematic groups with clear descriptions
4. Each item needs only `name` (must match compendium entry exactly) and `summary` (brief mechanical note for the LLM)
5. No item data — everything is loaded from compendium at runtime

---

## 9. Verification

- Generate a dragon-type NPC → expect: multiattack, bite/claw/tail attacks (generated), breath weapon + frightful presence + legendary actions (from catalog), appropriate spells if any
- Generate a spellcaster NPC → expect: spells from compendium on the sheet, spellcasting ability set, balanced spell selection
- Generate a simple beast → expect: attacks only, maybe a passive ability, no spells
- Check that catalog selection respects CR limits (low CR gets fewer abilities)
- Check that missing compendium entries are logged and skipped gracefully
- Re-apply after refinement → expect: old simsala-flagged items deleted, new ones created
- Check that waves 1–5 still work identically

---

## 10. Out of Scope (Future)

- Re-flavoring selected abilities (changing name, damage type, etc.)
- 3rd-party compendium catalog files
- User-facing catalog editor
- Caching compendium lookups across sessions
